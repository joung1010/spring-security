# Spring Security Authentication Events

## ê°œìš”

Spring SecurityëŠ” ì¸ì¦ì´ ì„±ê³µí•˜ê±°ë‚˜ ì‹¤íŒ¨í•˜ê²Œ ë˜ë©´ `AuthenticationSuccessEvent` ë˜ëŠ” `AuthenticationFailureEvent`ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤. ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ë ¤ë©´ `ApplicationEventPublisher`ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ Spring Securityì—ì„œ ì œê³µí•˜ëŠ” `AuthenticationEventPublisher`ë¥¼ ì‚¬ìš©í•´ì„œ ë°œí–‰í•´ì•¼ í•©ë‹ˆë‹¤.

## ì´ë²¤íŠ¸ ë°œí–‰ ë°©ë²•

### ë°œí–‰ API

- `ApplicationEventPublisher.publishEvent(ApplicationEvent)`
- `AuthenticationEventPublisher.publishAuthenticationSuccess(Authentication)`
- `AuthenticationEventPublisher.publishAuthenticationFailure(AuthenticationException, Authentication)`

### ìˆ˜ì‹  ë°©ë²•

```java
@Component
public class AuthenticationEvents {
    
    @EventListener
    public void onSuccess(AuthenticationSuccessEvent event) { ... }

    @EventListener
    public void onFailure(AbstractAuthenticationFailureEvent event) { ... }
}
```

---

## Spring ì´ë²¤íŠ¸ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜

### ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë‹ ì›ë¦¬

Springì˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë‹ ë©”ì»¤ë‹ˆì¦˜ì€ **ìë°” í´ë˜ìŠ¤ ìƒì† êµ¬ì¡°**ë¥¼ ë”°ë¥´ê¸° ë•Œë¬¸ì— íŠ¹ì • ì´ë²¤íŠ¸ì˜ ë¦¬ìŠ¤ë„ˆëŠ” í•´ë‹¹ ì´ë²¤íŠ¸ë¿ë§Œ ì•„ë‹ˆë¼ ê·¸ ì´ë²¤íŠ¸ì˜ **ë¶€ëª¨ í´ë˜ìŠ¤ ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë“¤ë¡œë¶€í„° ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ë„ ì²˜ë¦¬**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì´ë²¤íŠ¸ ì „íŒŒ êµ¬ì¡°

```java
// ìƒìœ„ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ë©´ í•˜ìœ„ ì´ë²¤íŠ¸ë„ ëª¨ë‘ ìˆ˜ì‹  ê°€ëŠ¥
@EventListener
public void handleParentEvent(AbstractAuthenticationEvent event) {
    // AuthenticationSuccessEvent, AbstractAuthenticationFailureEvent ëª¨ë‘ ìˆ˜ì‹ 
}

@EventListener
public void handleFailureEvents(AbstractAuthenticationFailureEvent event) {
    // ëª¨ë“  ì‹¤íŒ¨ ì´ë²¤íŠ¸ (BadCredentials, Disabled, Expired ë“±) ìˆ˜ì‹ 
}

@EventListener
public void handleSpecificFailure(AuthenticationFailureBadCredentialsEvent event) {
    // ì˜ëª»ëœ ìê²©ì¦ëª… ì‹¤íŒ¨ë§Œ ìˆ˜ì‹ 
}
```

---

## ì¸ì¦ ì´ë²¤íŠ¸ ì¢…ë¥˜

### ìƒìœ„ ì´ë²¤íŠ¸ í´ë˜ìŠ¤

### 1. AbstractAuthenticationEvent

```java
public abstract class AbstractAuthenticationEvent extends ApplicationEvent {
    private final Authentication authentication;
    
    public AbstractAuthenticationEvent(Authentication authentication) {
        super(authentication);
        this.authentication = authentication;
    }
    
    public Authentication getAuthentication() {
        return authentication;
    }
}
```

- **ì—­í• **: ì¸ì¦ ì„±ê³µ, ì‹¤íŒ¨ ì´ë²¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ìµœìƒìœ„ ì´ë²¤íŠ¸ í´ë˜ìŠ¤
- **í¬í•¨**: ëª¨ë“  ì¸ì¦ ê´€ë ¨ ì´ë²¤íŠ¸ì˜ ë¶€ëª¨ í´ë˜ìŠ¤

### 2. AbstractAuthenticationFailureEvent

```java
public abstract class AbstractAuthenticationFailureEvent extends AbstractAuthenticationEvent {
    private final AuthenticationException exception;
    
    public AbstractAuthenticationFailureEvent(Authentication authentication, AuthenticationException exception) {
        super(authentication);
        this.exception = exception;
    }
    
    public AuthenticationException getException() {
        return exception;
    }
}
```

- **ì—­í• **: ëª¨ë“  ì‹¤íŒ¨ ì´ë²¤íŠ¸ í´ë˜ìŠ¤ì˜ ìƒìœ„ ì´ë²¤íŠ¸ í´ë˜ìŠ¤
- **ì¶”ê°€ ì •ë³´**: ì‹¤íŒ¨ ì›ì¸ì„ ë‚˜íƒ€ë‚´ëŠ” `AuthenticationException` í¬í•¨

### ì¸ì¦ ì„±ê³µ ì´ë²¤íŠ¸ í´ë˜ìŠ¤

### 1. AuthenticationSuccessEvent

```java
public class AuthenticationSuccessEvent extends AbstractAuthenticationEvent {
    public AuthenticationSuccessEvent(Authentication authentication) {
        super(authentication);
    }
}
```

- **ë°œí–‰ ìœ„ì¹˜**: `ProviderManager.authenticate()` ì„±ê³µ ì‹œ
- **ìš©ë„**: ê¸°ë³¸ì ì¸ ì¸ì¦ ì„±ê³µ ì•Œë¦¼

### 2. InteractiveAuthenticationSuccessEvent

```java
public class InteractiveAuthenticationSuccessEvent extends ApplicationEvent {
    private final Authentication authentication;
    private final Class<?> generatedBy;
    
    public InteractiveAuthenticationSuccessEvent(Authentication authentication, Class<?> generatedBy) {
        super(authentication);
        this.authentication = authentication;
        this.generatedBy = generatedBy;
    }
}
```

- **ë°œí–‰ ìœ„ì¹˜**: `UsernamePasswordAuthenticationFilter` ë“±ì—ì„œ ì‚¬ìš©ì ìƒí˜¸ì‘ìš© í†µí•œ ì¸ì¦ ì„±ê³µ ì‹œ
- **íŠ¹ì§•**: ì‚¬ìš©ìê°€ ì§ì ‘ ë¡œê·¸ì¸ í¼ì„ í†µí•´ ì¸ì¦í•œ ê²½ìš°
- **ì¶”ê°€ ì •ë³´**: ì–´ë–¤ í•„í„°ì—ì„œ ë°œìƒí–ˆëŠ”ì§€ `generatedBy` ì •ë³´ í¬í•¨

### ì¸ì¦ ì‹¤íŒ¨ ì´ë²¤íŠ¸ í´ë˜ìŠ¤

| ì´ë²¤íŠ¸ í´ë˜ìŠ¤ | ë°œìƒ ìƒí™© | ê´€ë ¨ ì˜ˆì™¸ |
| --- | --- | --- |
| `AuthenticationFailureBadCredentialsEvent` | ì˜ëª»ëœ ìê²©ì¦ëª… | `BadCredentialsException` |
| `AuthenticationFailureCredentialsExpiredEvent` | ìê²©ì¦ëª… ë§Œë£Œ | `CredentialsExpiredException` |
| `AuthenticationFailureDisabledEvent` | ê³„ì • ë¹„í™œì„±í™” | `DisabledException` |
| `AuthenticationFailureExpiredEvent` | ê³„ì • ë§Œë£Œ | `AccountExpiredException` |
| `AuthenticationFailureLockedEvent` | ê³„ì • ì ê¸ˆ | `LockedException` |
| `AuthenticationFailureProviderNotFoundEvent` | ì¸ì¦ ì œê³µì ì—†ìŒ | `ProviderNotFoundException` |
| `AuthenticationFailureProxyUntrustedEvent` | ì‹ ë¢°í•  ìˆ˜ ì—†ëŠ” í”„ë¡ì‹œ | `ProxyUntrustedException` |
| `AuthenticationFailureServiceExceptionEvent` | ì¸ì¦ ì„œë¹„ìŠ¤ ì˜ˆì™¸ | `AuthenticationServiceException` |

---

## Spring Securityì—ì„œ ì‹¤ì œ ì´ë²¤íŠ¸ë¥¼ ë°œí–‰í•˜ëŠ” ì½”ë“œ

### 1. ProviderManagerì—ì„œ ì„±ê³µ ì´ë²¤íŠ¸ ë°œí–‰

```java
public class ProviderManager implements AuthenticationManager {
    
    private AuthenticationEventPublisher eventPublisher = new NullEventPublisher();
    
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        Class<? extends Authentication> toTest = authentication.getClass();
        AuthenticationException lastException = null;
        Authentication result = null;
        
        for (AuthenticationProvider provider : getProviders()) {
            if (!provider.supports(toTest)) {
                continue;
            }
            
            try {
                result = provider.authenticate(authentication);
                if (result != null) {
                    copyDetails(authentication, result);
                    break;
                }
            } catch (AccountStatusException | InternalAuthenticationServiceException ex) {
                prepareException(ex, authentication);
                throw ex;
            } catch (AuthenticationException ex) {
                lastException = ex;
            }
        }
        
        if (result != null) {
            if (this.eraseCredentialsAfterAuthentication && (result instanceof CredentialsContainer)) {
                ((CredentialsContainer) result).eraseCredentials();
            }
            
            // ğŸ”¥ ì„±ê³µ ì´ë²¤íŠ¸ ë°œí–‰
            if (this.eventPublisher != null) {
                this.eventPublisher.publishAuthenticationSuccess(result);
            }
            
            return result;
        }
        
        // ì‹¤íŒ¨ ì²˜ë¦¬
        if (lastException == null) {
            lastException = new ProviderNotFoundException(messages.getMessage("ProviderManager.providerNotFound",
                    new Object[] { toTest.getName() }, "No AuthenticationProvider found for {0}"));
        }
        
        // ğŸ”¥ ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë°œí–‰
        if (this.eventPublisher != null) {
            this.eventPublisher.publishAuthenticationFailure(lastException, authentication);
        }
        
        throw lastException;
    }
    
    public void setAuthenticationEventPublisher(AuthenticationEventPublisher eventPublisher) {
        Assert.notNull(eventPublisher, "AuthenticationEventPublisher cannot be null");
        this.eventPublisher = eventPublisher;
    }
}
```

### 2. UsernamePasswordAuthenticationFilterì—ì„œInteractiveAuthenticationSuccessEvent ë°œí–‰

```java
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        
        if (this.postOnly && !request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
        }
        
        String username = obtainUsername(request);
        String password = obtainPassword(request);
        
        if (username == null) {
            username = "";
        }
        if (password == null) {
            password = "";
        }
        
        username = username.trim();
        
        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
        setDetails(request, authRequest);
        
        return this.getAuthenticationManager().authenticate(authRequest);
    }
}

// AbstractAuthenticationProcessingFilterì—ì„œ ì„±ê³µ ì²˜ë¦¬
public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean {
    
    private ApplicationEventPublisher eventPublisher;
    
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
            FilterChain chain, Authentication authResult) throws IOException, ServletException {
        
        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authResult);
        SecurityContextHolder.setContext(context);
        
        this.securityContextRepository.saveContext(context, request, response);
        
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authResult));
        }
        
        this.rememberMeServices.loginSuccess(request, response, authResult);
        
        // ğŸ”¥ InteractiveAuthenticationSuccessEvent ë°œí–‰
        if (this.eventPublisher != null) {
            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));
        }
        
        this.successHandler.onAuthenticationSuccess(request, response, authResult);
    }
    
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
            AuthenticationException failed) throws IOException, ServletException {
        
        SecurityContextHolder.clearContext();
        
        this.logger.trace("Failed to process authentication request", failed);
        this.logger.trace("Cleared SecurityContextHolder");
        this.logger.trace("Handling authentication failure");
        
        this.rememberMeServices.loginFail(request, response);
        
        this.failureHandler.onAuthenticationFailure(request, response, failed);
    }
    
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
}
```

### 3. DefaultAuthenticationEventPublisherì—ì„œ ì‹¤ì œ ì´ë²¤íŠ¸ ë§¤í•‘

```java
public class DefaultAuthenticationEventPublisher implements AuthenticationEventPublisher {
    
    private final Map<Class<? extends AuthenticationException>, Class<? extends AbstractAuthenticationFailureEvent>> 
            exceptionMappings = new HashMap<>();
    
    private ApplicationEventPublisher applicationEventPublisher;
    
    public DefaultAuthenticationEventPublisher() {
        this(null);
    }
    
    public DefaultAuthenticationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
        addMapping(BadCredentialsException.class, AuthenticationFailureBadCredentialsEvent.class);
        addMapping(UsernameNotFoundException.class, AuthenticationFailureBadCredentialsEvent.class);
        addMapping(AccountExpiredException.class, AuthenticationFailureExpiredEvent.class);
        addMapping(ProviderNotFoundException.class, AuthenticationFailureProviderNotFoundEvent.class);
        addMapping(DisabledException.class, AuthenticationFailureDisabledEvent.class);
        addMapping(LockedException.class, AuthenticationFailureLockedEvent.class);
        addMapping(AuthenticationServiceException.class, AuthenticationFailureServiceExceptionEvent.class);
        addMapping(CredentialsExpiredException.class, AuthenticationFailureCredentialsExpiredEvent.class);
        addMapping(InsufficientAuthenticationException.class, AuthenticationFailureServiceExceptionEvent.class);
    }
    
    @Override
    public void publishAuthenticationSuccess(Authentication authentication) {
        if (this.applicationEventPublisher != null) {
            // ğŸ”¥ AuthenticationSuccessEvent ë°œí–‰
            this.applicationEventPublisher.publishEvent(new AuthenticationSuccessEvent(authentication));
        }
    }
    
    @Override
    public void publishAuthenticationFailure(AuthenticationException exception, Authentication authentication) {
        if (this.applicationEventPublisher != null) {
            // ğŸ”¥ ì˜ˆì™¸ íƒ€ì…ì— ë”°ë¥¸ ì ì ˆí•œ ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë°œí–‰
            Class<? extends AbstractAuthenticationFailureEvent> eventClass = this.exceptionMappings.get(exception.getClass());
            
            if (eventClass != null) {
                AbstractAuthenticationFailureEvent event = getAuthenticationFailureEvent(eventClass, authentication, exception);
                this.applicationEventPublisher.publishEvent(event);
            }
        }
    }
    
    private AbstractAuthenticationFailureEvent getAuthenticationFailureEvent(
            Class<? extends AbstractAuthenticationFailureEvent> eventClass, 
            Authentication authentication, 
            AuthenticationException exception) {
        
        try {
            Constructor<? extends AbstractAuthenticationFailureEvent> constructor = 
                eventClass.getConstructor(Authentication.class, AuthenticationException.class);
            return constructor.newInstance(authentication, exception);
        } catch (Exception ex) {
            throw new RuntimeException("Failed to create authentication failure event", ex);
        }
    }
    
    public void addMapping(Class<? extends AuthenticationException> exceptionClass,
            Class<? extends AbstractAuthenticationFailureEvent> eventClass) {
        this.exceptionMappings.put(exceptionClass, eventClass);
    }
    
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }
}
```

### 4. DaoAuthenticationProviderì—ì„œ êµ¬ì²´ì ì¸ ì˜ˆì™¸ ì²˜ë¦¬

```java
public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
    
    @Override
    protected void additionalAuthenticationChecks(UserDetails userDetails,
            UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        
        if (authentication.getCredentials() == null) {
            this.logger.debug("Failed to authenticate since no credentials provided");
            // ğŸ”¥ BadCredentialsException ë°œìƒ â†’ AuthenticationFailureBadCredentialsEventë¡œ ë³€í™˜ë¨
            throw new BadCredentialsException(this.messages
                    .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
        }
        
        String presentedPassword = authentication.getCredentials().toString();
        
        if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
            this.logger.debug("Failed to authenticate since password does not match stored value");
            // ğŸ”¥ BadCredentialsException ë°œìƒ â†’ AuthenticationFailureBadCredentialsEventë¡œ ë³€í™˜ë¨
            throw new BadCredentialsException(this.messages
                    .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
        }
    }
    
    @Override
    protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication)
            throws AuthenticationException {
        prepareTimingAttackProtection();
        try {
            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);
            if (loadedUser == null) {
                throw new InternalAuthenticationServiceException(
                        "UserDetailsService returned null, which is an interface contract violation");
            }
            return loadedUser;
        } catch (UsernameNotFoundException ex) {
            mitigateAgainstTimingAttack(authentication);
            // ğŸ”¥ UsernameNotFoundException ë°œìƒ â†’ AuthenticationFailureBadCredentialsEventë¡œ ë³€í™˜ë¨
            throw ex;
        } catch (InternalAuthenticationServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new InternalAuthenticationServiceException(ex.getMessage(), ex);
        }
    }
}
```

### 5. AbstractUserDetailsAuthenticationProviderì—ì„œ ê³„ì • ìƒíƒœ ê²€ì‚¬

```java
public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider {
    
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,
                () -> this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports",
                        "Only UsernamePasswordAuthenticationToken is supported"));
        
        String username = determineUsername(authentication);
        boolean cacheWasUsed = true;
        UserDetails user = this.userCache.getUserFromCache(username);
        
        if (user == null) {
            cacheWasUsed = false;
            try {
                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            } catch (UsernameNotFoundException ex) {
                this.logger.debug("Failed to find user '" + username + "'");
                if (!this.hideUserNotFoundExceptions) {
                    throw ex;
                }
                // ğŸ”¥ BadCredentialsException ë°œìƒ â†’ AuthenticationFailureBadCredentialsEventë¡œ ë³€í™˜ë¨
                throw new BadCredentialsException(this.messages
                        .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
            }
            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");
        }
        
        try {
            // ğŸ”¥ ê³„ì • ìƒíƒœ ê²€ì‚¬ - ê°ì¢… ì˜ˆì™¸ ë°œìƒ ê°€ëŠ¥
            this.preAuthenticationChecks.check(user);
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
        } catch (AuthenticationException ex) {
            if (!cacheWasUsed) {
                throw ex;
            }
            // ìºì‹œëœ ì‚¬ìš©ìë¡œ ì¬ì‹œë„
            cacheWasUsed = false;
            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            this.preAuthenticationChecks.check(user);
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
        }
        
        this.postAuthenticationChecks.check(user);
        
        if (!cacheWasUsed) {
            this.userCache.putUserInCache(user);
        }
        
        Object principalToReturn = user;
        if (this.forcePrincipalAsString) {
            principalToReturn = user.getUsername();
        }
        
        return createSuccessAuthentication(principalToReturn, authentication, user);
    }
    
    // ê³„ì • ìƒíƒœ ê²€ì‚¬ìë“¤
    private class DefaultPreAuthenticationChecks implements UserDetailsChecker {
        @Override
        public void check(UserDetails user) {
            if (!user.isAccountNonLocked()) {
                // ğŸ”¥ LockedException ë°œìƒ â†’ AuthenticationFailureLockedEventë¡œ ë³€í™˜ë¨
                throw new LockedException(AbstractUserDetailsAuthenticationProvider.this.messages
                        .getMessage("AbstractUserDetailsAuthenticationProvider.locked", "User account is locked"));
            }
            if (!user.isEnabled()) {
                // ğŸ”¥ DisabledException ë°œìƒ â†’ AuthenticationFailureDisabledEventë¡œ ë³€í™˜ë¨
                throw new DisabledException(AbstractUserDetailsAuthenticationProvider.this.messages
                        .getMessage("AbstractUserDetailsAuthenticationProvider.disabled", "User is disabled"));
            }
            if (!user.isAccountNonExpired()) {
                // ğŸ”¥ AccountExpiredException ë°œìƒ â†’ AuthenticationFailureExpiredEventë¡œ ë³€í™˜ë¨
                throw new AccountExpiredException(AbstractUserDetailsAuthenticationProvider.this.messages
                        .getMessage("AbstractUserDetailsAuthenticationProvider.expired", "User account has expired"));
            }
        }
    }
    
    private class DefaultPostAuthenticationChecks implements UserDetailsChecker {
        @Override
        public void check(UserDetails user) {
            if (!user.isCredentialsNonExpired()) {
                // ğŸ”¥ CredentialsExpiredException ë°œìƒ â†’ AuthenticationFailureCredentialsExpiredEventë¡œ ë³€í™˜ë¨
                throw new CredentialsExpiredException(AbstractUserDetailsAuthenticationProvider.this.messages
                        .getMessage("AbstractUserDetailsAuthenticationProvider.credentialsExpired",
                                "User credentials have expired"));
            }
        }
    }
}
```

## ì¸ì¦ ì„±ê³µ ì´ë²¤íŠ¸ ë°œí–‰ & ìˆ˜ì‹  ì˜ˆì œ

### 1. ì´ë²¤íŠ¸ ìˆ˜ì‹ ì êµ¬í˜„

```java
@Component
public class AuthenticationSuccessEvents {

    // ProviderManager > AuthenticationEventPublisher.publishAuthenticationSuccess()ì—ì„œ ë°œí–‰
    @EventListener
    public void onSuccess(AuthenticationSuccessEvent event) {
        System.out.println("=== ê¸°ë³¸ ì¸ì¦ ì„±ê³µ ===");
        System.out.println("ì‚¬ìš©ì: " + event.getAuthentication().getName());
        System.out.println("ê¶Œí•œ: " + event.getAuthentication().getAuthorities());
        System.out.println("ì¸ì¦ íƒ€ì…: " + event.getAuthentication().getClass().getSimpleName());
    }

    // UsernamePasswordAuthenticationFilter > ApplicationEventPublisher.publishEvent()ì—ì„œ ë°œí–‰
    @EventListener
    public void onSuccess(InteractiveAuthenticationSuccessEvent event) {
        System.out.println("=== ëŒ€í™”í˜• ì¸ì¦ ì„±ê³µ ===");
        System.out.println("ì‚¬ìš©ì: " + event.getAuthentication().getName());
        System.out.println("ë°œí–‰ì: " + event.getGeneratedBy().getSimpleName());
    }

    // ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ìˆ˜ì‹ 
    @EventListener
    public void onSuccess(CustomAuthenticationEvent event) {
        System.out.println("=== ì»¤ìŠ¤í…€ ì¸ì¦ ì´ë²¤íŠ¸ ===");
        System.out.println("ì‚¬ìš©ì: " + event.getAuthentication().getName());
        System.out.println("ì¶”ê°€ ë°ì´í„°: " + event.getCustomData());
    }
}
```

### 2. ì»¤ìŠ¤í…€ ì¸ì¦ ì´ë²¤íŠ¸ ë°œí–‰

```java
@Component
public class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public CustomAuthenticationSuccessHandler(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, 
                                      FilterChain chain, Authentication authentication) 
                                      throws IOException, ServletException {
        
        // ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ë°œí–‰
        eventPublisher.publishEvent(new CustomAuthenticationEvent(authentication, "Custom Login Success"));
        
        chain.doFilter(request, response);
    }
    
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, 
                                      Authentication authentication) throws IOException, ServletException {
        response.sendRedirect("/dashboard");
    }
}
```

---

## ì¸ì¦ ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë°œí–‰ & ìˆ˜ì‹ 

### 1. ì‹¤íŒ¨ ì´ë²¤íŠ¸ ìˆ˜ì‹ ì êµ¬í˜„

```java
@Component
public class AuthenticationFailureEvents {
    
    // AbstractAuthenticationFailureEventì˜ ëª¨ë“  í•˜ìœ„ í´ë˜ìŠ¤ ì´ë²¤íŠ¸ ìˆ˜ì‹ 
    @EventListener
    public void onFailure(AbstractAuthenticationFailureEvent event) {
        System.out.println("=== ì¸ì¦ ì‹¤íŒ¨ (ê³µí†µ) ===");
        System.out.println("ì‚¬ìš©ì: " + (event.getAuthentication() != null ? 
                          event.getAuthentication().getName() : "unknown"));
        System.out.println("ì˜ˆì™¸: " + event.getException().getClass().getSimpleName());
        System.out.println("ë©”ì‹œì§€: " + event.getException().getMessage());
    }

    @EventListener
    public void onFailure(AuthenticationFailureBadCredentialsEvent event) {
        System.out.println("=== ì˜ëª»ëœ ìê²©ì¦ëª… ===");
        System.out.println("ì‚¬ìš©ì: " + event.getAuthentication().getName());
    }

    @EventListener
    public void onFailure(AuthenticationFailureDisabledEvent event) {
        System.out.println("=== ê³„ì • ë¹„í™œì„±í™” ===");
        System.out.println("ì‚¬ìš©ì: " + event.getAuthentication().getName());
    }
}
```

### 2. ApplicationEventPublisher ë˜ëŠ” AuthenticationEventPublisherë¥¼ í†µí•œ ì´ë²¤íŠ¸ ë°œí–‰

```java
@Service
public class CustomAuthenticationService {
    
    private final ApplicationEventPublisher applicationEventPublisher;
    private final AuthenticationEventPublisher authenticationEventPublisher;
    
    public CustomAuthenticationService(ApplicationEventPublisher applicationEventPublisher,
                                     AuthenticationEventPublisher authenticationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
        this.authenticationEventPublisher = authenticationEventPublisher;
    }
    
    public void manualAuthenticationSuccess(Authentication authentication) {
        // ë°©ë²• 1: ApplicationEventPublisher ì‚¬ìš©
        applicationEventPublisher.publishEvent(new AuthenticationSuccessEvent(authentication));
        
        // ë°©ë²• 2: AuthenticationEventPublisher ì‚¬ìš©
        authenticationEventPublisher.publishAuthenticationSuccess(authentication);
    }
    
    public void manualAuthenticationFailure(AuthenticationException exception, Authentication authentication) {
        // ë°©ë²• 1: ApplicationEventPublisher ì‚¬ìš©
        applicationEventPublisher.publishEvent(new AuthenticationFailureBadCredentialsEvent(authentication, exception));
        
        // ë°©ë²• 2: AuthenticationEventPublisher ì‚¬ìš©
        authenticationEventPublisher.publishAuthenticationFailure(exception, authentication);
    }
}
```

ì´ë ‡ê²Œ Spring SecurityëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `ProviderManager`, `AbstractAuthenticationProcessingFilter`, `DefaultAuthenticationEventPublisher` ë“±ì—ì„œ ì²´ê³„ì ìœ¼ë¡œ ì¸ì¦ ì´ë²¤íŠ¸ë¥¼ ë°œí–‰í•˜ê³ , ê°œë°œìëŠ” `@EventListener`ë¥¼ í†µí•´ ì´ëŸ¬í•œ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ì—¬ ì¶”ê°€ì ì¸ ë³´ì•ˆ ë¡œì§ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.