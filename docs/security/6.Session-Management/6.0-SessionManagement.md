## 동시 세션제어
- 동시 세션 제어는 사용자가 동시에 여러 세션을 생성하는 것을 관리하는 전략
- 사용자의 인증 후에 활성화된 세션의 수가 설정된 maximumSessions 값과 비교하여 제어 여부를 결정

### 세션(Session)이란?

세션은 클라이언트와 서버 간의 상태를 유지하기 위해 사용하는 데이터 구조입니다. HTTP는 기본적으로 **무상태(stateless) 프로토콜**이기 때문에, 클라이언트의 요청과 서버의 응답 사이에 상태를 유지하려면 추가적인 메커니즘이 필요합니다. 세션은 이러한 상태 유지를 가능하게 합니다.

### 세션의 동작 방식

1. **클라이언트의 요청**: 클라이언트가 서버에 로그인 요청을 보냅니다.
2. **세션 생성**: 서버는 사용자를 인증한 후 세션을 생성하고, 고유 식별자(세션 ID)를 부여합니다.
3. **세션 저장**: 서버는 세션 ID를 클라이언트 측 쿠키 또는 URL에 저장하고, 관련 데이터를 서버(메모리, 파일, DB 등)에 저장합니다.
4. **세션 활용**: 클라이언트는 세션 ID를 서버에 계속 전달하며, 서버는 이를 통해 클라이언트의 상태를 확인하고 필요한 데이터를 제공합니다.
5. **세션 종료**: 로그아웃 시 세션을 삭제하거나, 일정 시간이 지나면 세션이 만료됩니다.

### 세션의 주요 특성

- **상태 유지**: 사용자가 로그인한 상태를 유지하거나, 장바구니 데이터를 유지하는 등.
- **유효 기간**: 세션에는 일반적으로 유효 기간이 설정되며, 유효 시간이 지나면 만료됩니다.
- **보안**: 세션 하이재킹(세션 탈취) 방지를 위해 HTTPS와 같은 보안 프로토콜을 사용해야 합니다.

### 예시

- 사용자가 전자상거래 웹사이트에 로그인한 후 상품을 장바구니에 추가한 상태를 유지하는 경우, 서버는 이 데이터를 세션에 저장합니다.
- 브라우저를 닫았다가 다시 열어도 로그인 상태가 유지된다면, 세션이 서버와 브라우저 간에 적절히 동작하고 있다는 의미입니다.
  
  

---  

## **스프링 시큐리티에서의 세션 제어**

Spring Security는 애플리케이션의 인증과 권한 부여를 처리하며, 이를 통해 세션도 관리합니다. 동시 세션 제어는 여러 사용자 세션을 관리하고 제한하는 중요한 기능 중 하나입니다.

### 동시 세션 제어란?

동시 세션 제어는 동일한 사용자가 여러 디바이스 또는 브라우저에서 동시에 로그인하는 것을 허용할지, 아니면 제한할지 결정하는 기능입니다. 예를 들어, 한 사용자가 이미 로그인한 상태에서 다른 브라우저로 다시 로그인하면 이전 세션을 만료시키거나, 새로운 세션 생성을 막을 수 있습니다.

## **동시 세션 제어를 사용하는 이유**

1. **보안 강화**: 한 계정을 여러 사용자가 공유하거나, 세션 하이재킹으로 인한 악용을 방지합니다.
2. **리소스 관리**: 서버 자원을 효율적으로 관리할 수 있습니다.
3. **정책 준수**: 금융, 의료와 같은 특정 산업에서는 동시 세션이 정책적으로 금지되기도 합니다.
  
  
    

---  



  
### 동시 세션제어 유형 2가지  

###  사용자 인증 시도 차단

**시나리오 1: 동일 계정 중복 로그인 제한**  

1. 사용자 A가 브라우저 1에서 로그인하여 세션 1을 생성합니다.
2. 사용자 A가 브라우저 2에서 같은 계정으로 로그인하려고 시도합니다.
3. `maxSessionsPreventsLogin(true)`로 설정된 경우, 브라우저 2의 로그인은 거부됩니다.
  
**`최대 허용 개수만큼 동시 인증이 가능하고 그 외 사용자의 인증 시도를 차단`**  
  
![img_8.png](../../img/img_8.png)

###  사용자 세션 강제 만료

**시나리오 2: 기존 세션 만료 처리**  

1. 사용자 B가 디바이스 1에서 로그인합니다(세션 ID: S1).
2. 사용자 B가 디바이스 2에서 로그인합니다(세션 ID: S2).
3. `maxSessionsPreventsLogin(false)`로 설정된 경우, 디바이스 1의 세션 S1이 만료됩니다.
4. 만료된 세션으로 요청 시, `/session-expired` URL로 리다이렉트됩니다.

**`최대 허용 개수만큼 동시 인증이 가능하고 그 외 이전 사용자의 세션을 만료`**
  
![6.0-SessionManagement.md](../../img/img_7.png)
  
### 설정 클레스
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
                .and()
            .logout()
                .permitAll()
                .and()
            .sessionManagement()
                .maximumSessions(1) // 한 사용자당 최대 세션 수 제한
                .maxSessionsPreventsLogin(true) // 추가 로그인 방지(true) 또는 기존 세션 종료(false)
                .expiredUrl("/session-expired"); // 세션 만료 시 리다이렉트 URL
    }
}

```

### 주요 옵션

1. `maximumSessions(int maxSessions)`: 사용자당 허용할 최대 세션 수를 설정합니다. 기본값은 무제한 세션을 허용한다.
2. `maxSessionsPreventsLogin(boolean flag)`:
    - `true`: 새로운 세션 생성을 막음.
    - `false`: 이전 세션을 만료시킴(기본값).
3. `expiredUrl(String url)`: 세션 만료 시 이동할 URL을 설정합니다.
4. `invalidSessionUrl(String url)`: 사용자가 유효하지 않은 세션으로 서버에 접근할 경우, 지정된 URL로 리다이렉트합니다.

### **`expiredUrl`와 `invalidSessionUrl` 비교**

| **옵션** | **`expiredUrl`** | **`invalidSessionUrl`** |
| --- | --- | --- |
| **적용 상황** | 기존 세션이 만료되었을 때 | 유효하지 않은 세션으로 접근했을 때 |
| **주요 발생 원인** | - 동일 계정으로 새로운 세션 생성 시- 세션 시간이 만료된 경우 | - 서버 재시작으로 세션 초기화- 세션이 아예 존재하지 않을 때 |
| **설정 위치** | `sessionManagement().maximumSessions().expiredUrl()` | `sessionManagement().invalidSessionUrl()` |
| **동작 방식** | - 유효하던 세션이 만료되었음을 알려줌- 만료 이후 특정 URL로 리다이렉트 | - 서버가 요청에서 세션을 찾지 못할 경우- 특정 URL로 리다이렉트 |
| **사용자 경험** | 만료된 세션에 대해 사용자에게 알림 제공 | 초기 요청이 잘못되었음을 알려줌 |
| **사용 예제** | "다른 기기에서 로그인하여 세션이 종료되었습니다." 메시지 제공 | "세션이 만료되었습니다. 다시 로그인해주세요." 메시지 제공 |

### **정리**

- **`expiredUrl`**: 기존 세션이 유효했으나 만료된 경우에 대응하는 옵션입니다. 동일 계정으로 새로운 세션이 생성되거나, 세션 시간이 만료된 경우에 유용합니다.
- **`invalidSessionUrl`**: 세션이 유효하지 않을 때 대응하는 옵션입니다. 서버가 세션을 찾지 못할 때나, 사용자가 만료된 세션으로 접근하려고 할 때 사용됩니다.
  
  
## 세션 고정 보호 전략

### **세션 고정 공격(Session Fixation Attack)이란?**

세션 고정 공격은 악의적인 사용자가 미리 생성한 세션 ID를 피해자에게 고정하여 해당 세션을 사용하게 만든 뒤, 이를 통해 피해자의 세션을 탈취하는 공격 방식입니다.

### **공격 과정**

1. **세션 ID 생성**: 공격자가 애플리케이션에서 유효한 세션 ID를 미리 생성합니다.
2. **세션 ID 고정**: 공격자가 이 세션 ID를 URL 파라미터나 쿠키를 통해 피해자에게 전달하여 강제로 사용하게 합니다.
3. **세션 탈취**: 피해자가 해당 세션 ID로 로그인하면, 공격자는 동일한 세션 ID를 사용해 피해자의 세션에 접근할 수 있게 됩니다.

---

### **세션 고정 보호란?**

세션 고정 공격을 방지하기 위해, `Spring Security`는 로그인 과정에서 기존 세션을 무효화하거나, 새로운 세션 ID를 생성하여 세션 ID를 고정할 수 없게 합니다.


### **Spring Security에서의 세션 고정 보호 전략**

Spring Security는 세션 고정 공격에 대한 방어를 자동으로 제공합니다. 이를 통해 세션 ID를 안전하게 관리하며, 다양한 전략으로 보호 설정을 변경할 수 있습니다.

### **세션 고정 보호 전략 옵션**

Spring Security는 `sessionFixation().strategy()`를 통해 다음과 같은 전략을 제공합니다.

| **전략** | **설명**                                                                            |
| --- |-----------------------------------------------------------------------------------|
| **`changeSessionId`** | (기본값)기존 세션을 유지하며 세션 ID만 변경합니다. 데이터 보존과 성능 최적화를 동시에 제공합니다(Java Servlet 3.1 이상 필요). |
| **`migrateSession`** | 기존 세션을 새로운 세션 ID로 교체하고, 세션 데이터를 보존합니다.                                            |
| **`newSession`** | 새로운 세션 ID를 생성하며, 기존 세션 데이터를 제거합니다.                                                |
| **`none`** | 세션 고정 보호를 비활성화합니다. 기존 세션 ID가 그대로 유지되며 보안에 취약할 수 있습니다.                             |

### **세션 고정 보호 전략 설정**

### **세션 ID만 변경(`changeSessionId`)**

새로운 세션을 생성하지 않고, 기존 세션 데이터는 그대로 유지한 채로 세션 ID만 교체합니다. 이는 migrateSession()의 동작과 유사하지만, 보다 가벼운 방식으로 동작합니다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .permitAll()
            )
            .sessionManagement(session -> session
                .sessionFixation(sessionFixation -> sessionFixation
                    .changeSessionId() // 세션 ID만 변경, 데이터 유지
                )
            );

        return http.build();
    }
}

```
  

### **새로운 세션 ID로 교체(migrateSession)**

`Spring Security`는 기본적으로 세션 고정 보호를 활성화하며, `migrateSession` 전략을 사용합니다. 기존 세션 ID는 무효화되고, 새로운 세션 ID가 생성됩니다. 그러나 세션에 저장된 데이터는 유지됩니다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

   @Bean
   public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
              .authorizeHttpRequests(auth -> auth
                      .anyRequest().authenticated()
              )
              .formLogin(form -> form
                      .loginPage("/login")
                      .permitAll()
              )
              .sessionManagement(session -> session
                      .sessionFixation(sessionFixation -> sessionFixation
                              .migrateSession() // 세션 ID 교체, 데이터 유지
                      )
              );

      return http.build();
   }
}


```

### **새로운 세션 생성(`newSession`)**

기존 세션 ID뿐만 아니라 세션 데이터도 모두 제거합니다. 민감 데이터가 세션에 저장된 경우 사용을 고려할 수 있습니다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

   @Bean
   public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
              .authorizeHttpRequests(auth -> auth
                      .anyRequest().authenticated()
              )
              .formLogin(form -> form
                      .loginPage("/login")
                      .permitAll()
              )
              .sessionManagement(session -> session
                      .sessionFixation(sessionFixation -> sessionFixation
                              .newSession() // 새로운 세션 생성, 기존 데이터 제거
                      )
              );

      return http.build();
   }
}


```

### **보호 비활성화(`none`)**

세션 고정 보호를 비활성화하여 기존 세션 ID를 그대로 유지합니다. 이 옵션은 보안에 취약하며 일반적으로 사용하지 않는 것이 좋습니다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

   @Bean
   public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
              .authorizeHttpRequests(auth -> auth
                      .anyRequest().authenticated()
              )
              .formLogin(form -> form
                      .loginPage("/login")
                      .permitAll()
              )
              .sessionManagement(session -> session
                      .sessionFixation(sessionFixation -> sessionFixation
                              .none() // 세션 고정 보호 비활성화 (비추천)
                      )
              );

      return http.build();
   }
}


```
  

---

### **세션 고정 보호 전략에 따른 동작 비교**

| **옵션** | **동작** | **세션 ID 변경 여부** | **세션 데이터 유지 여부** | **주요 사용 사례** |
| --- | --- | --- | --- | --- |
| `migrateSession` | 새로운 세션 생성, 기존 데이터 이관 | **변경됨** | **유지** | 보안이 중요하면서도 기존 세션 데이터를 유지해야 할 때. |
| `newSession` | 새로운 세션 생성, 기존 데이터 제거 | **변경됨** | **제거됨** | 민감 데이터를 삭제하고 세션을 완전히 초기화할 때. |
| `none` | 세션 고정 보호 비활성화 | **변경되지 않음** | **유지** | 테스트 환경 등 특별한 요구가 있을 때. |
| `changeSessionId` | **세션 ID만 변경**, 기존 데이터 유지 | **변경됨** | **유지** | 성능이 중요하고 기본 보안을 유지해야 할 때. |