## 동시 세션제어
- 동시 세션 제어는 사용자가 동시에 여러 세션을 생성하는 것을 관리하는 전략
- 사용자의 인증 후에 활성화된 세션의 수가 설정된 maximumSessions 값과 비교하여 제어 여부를 결정

### 세션(Session)이란?

세션은 클라이언트와 서버 간의 상태를 유지하기 위해 사용하는 데이터 구조입니다. HTTP는 기본적으로 **무상태(stateless) 프로토콜**이기 때문에, 클라이언트의 요청과 서버의 응답 사이에 상태를 유지하려면 추가적인 메커니즘이 필요합니다. 세션은 이러한 상태 유지를 가능하게 합니다.

### 세션의 동작 방식

1. **클라이언트의 요청**: 클라이언트가 서버에 로그인 요청을 보냅니다.
2. **세션 생성**: 서버는 사용자를 인증한 후 세션을 생성하고, 고유 식별자(세션 ID)를 부여합니다.
3. **세션 저장**: 서버는 세션 ID를 클라이언트 측 쿠키 또는 URL에 저장하고, 관련 데이터를 서버(메모리, 파일, DB 등)에 저장합니다.
4. **세션 활용**: 클라이언트는 세션 ID를 서버에 계속 전달하며, 서버는 이를 통해 클라이언트의 상태를 확인하고 필요한 데이터를 제공합니다.
5. **세션 종료**: 로그아웃 시 세션을 삭제하거나, 일정 시간이 지나면 세션이 만료됩니다.

### 세션의 주요 특성

- **상태 유지**: 사용자가 로그인한 상태를 유지하거나, 장바구니 데이터를 유지하는 등.
- **유효 기간**: 세션에는 일반적으로 유효 기간이 설정되며, 유효 시간이 지나면 만료됩니다.
- **보안**: 세션 하이재킹(세션 탈취) 방지를 위해 HTTPS와 같은 보안 프로토콜을 사용해야 합니다.

### 예시

- 사용자가 전자상거래 웹사이트에 로그인한 후 상품을 장바구니에 추가한 상태를 유지하는 경우, 서버는 이 데이터를 세션에 저장합니다.
- 브라우저를 닫았다가 다시 열어도 로그인 상태가 유지된다면, 세션이 서버와 브라우저 간에 적절히 동작하고 있다는 의미입니다.
  
  

---  

## **스프링 시큐리티에서의 세션 제어**

Spring Security는 애플리케이션의 인증과 권한 부여를 처리하며, 이를 통해 세션도 관리합니다. 동시 세션 제어는 여러 사용자 세션을 관리하고 제한하는 중요한 기능 중 하나입니다.

### 동시 세션 제어란?

동시 세션 제어는 동일한 사용자가 여러 디바이스 또는 브라우저에서 동시에 로그인하는 것을 허용할지, 아니면 제한할지 결정하는 기능입니다. 예를 들어, 한 사용자가 이미 로그인한 상태에서 다른 브라우저로 다시 로그인하면 이전 세션을 만료시키거나, 새로운 세션 생성을 막을 수 있습니다.

## **동시 세션 제어를 사용하는 이유**

1. **보안 강화**: 한 계정을 여러 사용자가 공유하거나, 세션 하이재킹으로 인한 악용을 방지합니다.
2. **리소스 관리**: 서버 자원을 효율적으로 관리할 수 있습니다.
3. **정책 준수**: 금융, 의료와 같은 특정 산업에서는 동시 세션이 정책적으로 금지되기도 합니다.
  
  
    

---  



  
### 동시 세션제어 유형 2가지  

###  사용자 인증 시도 차단

**시나리오 1: 동일 계정 중복 로그인 제한**  

1. 사용자 A가 브라우저 1에서 로그인하여 세션 1을 생성합니다.
2. 사용자 A가 브라우저 2에서 같은 계정으로 로그인하려고 시도합니다.
3. `maxSessionsPreventsLogin(true)`로 설정된 경우, 브라우저 2의 로그인은 거부됩니다.
  
**`최대 허용 개수만큼 동시 인증이 가능하고 그 외 사용자의 인증 시도를 차단`**  

###  사용자 세션 강제 만료

**시나리오 2: 기존 세션 만료 처리**  

1. 사용자 B가 디바이스 1에서 로그인합니다(세션 ID: S1).
2. 사용자 B가 디바이스 2에서 로그인합니다(세션 ID: S2).
3. `maxSessionsPreventsLogin(false)`로 설정된 경우, 디바이스 1의 세션 S1이 만료됩니다.
4. 만료된 세션으로 요청 시, `/session-expired` URL로 리다이렉트됩니다.

**`최대 허용 개수만큼 동시 인증이 가능하고 그 외 이전 사용자의 세션을 만료`**
  
  
### 설정 클레스
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
                .and()
            .logout()
                .permitAll()
                .and()
            .sessionManagement()
                .maximumSessions(1) // 한 사용자당 최대 세션 수 제한
                .maxSessionsPreventsLogin(true) // 추가 로그인 방지(true) 또는 기존 세션 종료(false)
                .expiredUrl("/session-expired"); // 세션 만료 시 리다이렉트 URL
    }
}

```

### 주요 옵션

1. `maximumSessions(int maxSessions)`: 사용자당 허용할 최대 세션 수를 설정합니다. 기본값은 무제한 세션을 허용한다.
2. `maxSessionsPreventsLogin(boolean flag)`:
    - `true`: 새로운 세션 생성을 막음.
    - `false`: 이전 세션을 만료시킴(기본값).
3. `expiredUrl(String url)`: 세션 만료 시 이동할 URL을 설정합니다.
4. `invalidSessionUrl(String url)`: 사용자가 유효하지 않은 세션으로 서버에 접근할 경우, 지정된 URL로 리다이렉트합니다.

### **`expiredUrl`와 `invalidSessionUrl` 비교**

| **옵션** | **`expiredUrl`** | **`invalidSessionUrl`** |
| --- | --- | --- |
| **적용 상황** | 기존 세션이 만료되었을 때 | 유효하지 않은 세션으로 접근했을 때 |
| **주요 발생 원인** | - 동일 계정으로 새로운 세션 생성 시- 세션 시간이 만료된 경우 | - 서버 재시작으로 세션 초기화- 세션이 아예 존재하지 않을 때 |
| **설정 위치** | `sessionManagement().maximumSessions().expiredUrl()` | `sessionManagement().invalidSessionUrl()` |
| **동작 방식** | - 유효하던 세션이 만료되었음을 알려줌- 만료 이후 특정 URL로 리다이렉트 | - 서버가 요청에서 세션을 찾지 못할 경우- 특정 URL로 리다이렉트 |
| **사용자 경험** | 만료된 세션에 대해 사용자에게 알림 제공 | 초기 요청이 잘못되었음을 알려줌 |
| **사용 예제** | "다른 기기에서 로그인하여 세션이 종료되었습니다." 메시지 제공 | "세션이 만료되었습니다. 다시 로그인해주세요." 메시지 제공 |

### **정리**

- **`expiredUrl`**: 기존 세션이 유효했으나 만료된 경우에 대응하는 옵션입니다. 동일 계정으로 새로운 세션이 생성되거나, 세션 시간이 만료된 경우에 유용합니다.
- **`invalidSessionUrl`**: 세션이 유효하지 않을 때 대응하는 옵션입니다. 서버가 세션을 찾지 못할 때나, 사용자가 만료된 세션으로 접근하려고 할 때 사용됩니다.
  
