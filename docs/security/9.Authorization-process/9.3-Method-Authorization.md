## 메서드기반 권한 부여
Spring Security 는 요청 수준의 권한 부여뿐만 아니라 메서드 수준에서의 권한 부여를 지원한다. 메서디 수준 권한 부여를 활성하기 위해서는 설정 클래스에 `@EanbleMethodSecurity` 어노테이션을 추가해야 한다.

SpEL(Spring Expression Language) 표현식을 사용하여 다양한 보안 조건을 정의할 수 있다.

---

## 메서드 수준 보안의 활성화

Spring Security 6.x 기준으로 메서드 수준 보안을 활성화하는 방법은 다음과 같습니다:

```java

@Configuration
@EnableMethodSecurity
public class SecurityConfig {
// 보안 설정
}

```

### @EnableMethodSecurity

```java
public @interface EnableMethodSecurity {
    boolean prePostEnabled() default true;

    boolean securedEnabled() default false;

    boolean jsr250Enabled() default false;

    boolean proxyTargetClass() default false;

    AdviceMode mode() default AdviceMode.PROXY;

    int offset() default 0;
}
```

- **jsr250Enabled: `@**RolesAllowed` `@PermitAll` `@DenyAll` 을 활성화 한다.
- **prePostEnabled: `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, `@PostFilter`** 을 활성화환다.
- **securedEnabled: `@Secured`** 를 활성화 한다.

---

## 메서드 보안 어노테이션

## 주요 어노테이션

| 어노테이션 | 설명 | SpEL 예시 |
| --- | --- | --- |
| `@PreAuthorize` | 메서드 **호출 전** 권한 검사 | `@PreAuthorize("hasRole('ADMIN')")` |
| `@PostAuthorize` | 메서드 **호출 후** 반환값 기반 권한 검사 | `@PostAuthorize("returnObject.owner == authentication.name")` |
| `@PreFilter` | 메서드 파라미터(컬렉션) 필터링 | `@PreFilter("filterObject.owner == authentication.name")` |
| `@PostFilter` | 메서드 반환값(컬렉션) 필터링 | `@PostFilter("filterObject.active")` |
| `@Secured` | 단순 역할 기반(ROLE_) 검사 | `@Secured("ROLE_USER")` |
| `@RolesAllowed` | JSR-250 방식 역할 기반 | `@RolesAllowed("ADMIN")` |

---

### @PreAuthorize

메서드 실행 전에 보안 조건을 검사합니다. SpEL을 사용하여 복잡한 조건을 정의할 수 있습니다.

```java
@Service
public class UserService {
    
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        // 관리자 역할을 가진 사용자만 실행할 수 있는 메서드
    }
    
	  @PreAuthorize("hasRole('ADMIN','USER')")
    public List<User> getAllUsers() {
        // 관리자 또는 사용자 역할을 가진 사용자만 실행할 수 있는 메서드
    }
    
    @PreAuthorize("isAuthenticated()")
    public List<User> getAllUsers() {
        // 인증된 사용자만 실행할 수 있는 메서드
    }
    
    @PreAuthorize("hasRole('ADMIN') or #username == authentication.principal.username")
    public User getUserByUsername(String username) {
        // 사용자 이름으로 조회 로직
        // 메스드의 파라미터로 들어온 username 과 인증된 사용자명이 일치하는지 확
    }
}
```

---

### @PostAuthorize

메서드 실행 후에 보안 조건을 검사합니다. 반환값에 대한 검사가 가능합니다.

```java
@PostAuthorize("returnObject.username == authentication.name")
public User loadUserDetails(Long id) {
    // 사용자 정보를 반환하지만 소유자만 결과를 확인 가능
    return userRepository.findById(id).orElse(null);
}

@PostAuthorize("hasAuthority('ROLE_ADMIN') and returnObject.isSecure")
public User getSecureAndAdminAccount(Long id) {
    // 사용자 정보를 반환하지만 관리자만 결과를 볼 수 있음
    return userRepository.findById(id).orElse(null);
}
```

```java
@PostAuthorize("returnObject != null and (returnObject.status == 'APPR' or hasAuthority('ROLE_ADMIN'))")
public User updateRequestStatus(Long id) {
    return userRepository.findById(id).orElse(null);
}
```
  

---

### @PreFilter

`@PreFilter` 어노테이션은 메소드가 실행되기 전에 메소드의 인자(컬렉션이나 배열)를 필터링하는 기능을 제공합니다. 주로 사용자가 보내온 컬렉션(배열, 리스트, 맵, 스트림)내의 객체들을 특정 기준에 따라 필터링하고 그 중 보안 조건을 만족하는 객체들에 대해서만 메서드가 처리하도록 할 때 사용한다.

### 작동 원리

1. 메소드 호출 전에 실행됩니다.
2. 컬렉션이나 배열 형태의 파라미터에 대해 필터링을 수행합니다.
3. SpEL(Spring Expression Language)을 사용하여 필터링 조건을 정의합니다.
4. 조건에 부합하는 요소만 메소드로 전달됩니다.

### 예제

```graphql
 @PreFilter("filterObject.owner == authentication.name")
    public List<Document> processDocuments(List<Document> documents) {
        // 이 메소드로는 현재 인증된 사용자가 소유한 문서만 전달됩니다
        return documents.stream()
                .map(this::processDocument)
                .toList();
    }
```

여러 컬렉션 매개변수가 있을 경우 `filterTarget` 속성을 사용하여 특정 매개변수를 지정할 수 있습니다:

```java

java
@PreFilter(value = "filterObject.owner == authentication.name",
           filterTarget = "documents")
public void processDocumentsAndUsers(List<Document> documents, List<User> users) {
// documents 컬렉션만 필터링됨
}

```

### @PostFilter

`@PostFilter` 어노테이션은 메소드 실행 후 반환된 컬렉션이나 배열에서 특정 조건에 맞는 요소만 필터링하여 최종적으로 반환합니다. 반환된 컬렉션의 각 객체가 특정 보안 조건을 충족하는지 확인하고 조건을 만족하지 않는 객체들을 결과에서 제거한다.

### 작동 원리

1. 메소드가 실행되고 결과가 반환된 후에 동작합니다.
2. 반환된 컬렉션이나 배열의 각 요소에 대해 필터링을 수행합니다.
3. SpEL 조건에 맞는 요소만 최종적으로 반환됩니다.

### 예제

```graphql
 @PostFilter("filterObject.isPublic or filterObject.owner == authentication.name")
    public List<Document> getDocuments() {
        // 모든 문서를 조회한 후, 공개 문서 또는 현재 인증된 사용자가 소유한 문서만 반환
        return documentRepository.findAll();
    }
```

## 내부 구현 방식

Spring Security의 `@PreFilter`와 `@PostFilter`는 AOP(Aspect-Oriented Programming)와 스프링의 프록시 메커니즘을 활용하여 구현됩니다.

### 핵심 구현 클래스

1. **PrePostAnnotationSecurityMetadataSource**: 어노테이션에서 보안 메타데이터를 추출합니다.
2. **PreInvocationAuthorizationAdviceVoter**: 사전 필터링 로직을 투표자로 구현합니다.
3. **ExpressionBasedPreInvocationAdvice**: SpEL 표현식을 평가합니다.
4. **FilterInvocationSecurityMetadataSource**: 보안 메타데이터 소스를 제공합니다.
5. **MethodSecurityInterceptor**: 메소드 호출을 가로채 보안 검사를 수행합니다.

### 필터링 과정 (내부 구현)

```java
// PrePostAdviceMethodInterceptor의 내부 구현 일부 (유사 코드)
public class PrePostAdviceMethodInterceptor extends AbstractMethodInterceptor {

    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
// 메서드에서 @PreFilter 어노테이션 처리
        if (hasPreFilterAnnotation(mi.getMethod())) {
            Object[] filteredArgs = preFilter(mi.getArguments(), mi.getMethod());
            mi = new MethodInvocationWithModifiedArguments(mi, filteredArgs);
        }

// 메서드 실행
        Object result = mi.proceed();

// 메서드에서 @PostFilter 어노테이션 처리
        if (hasPostFilterAnnotation(mi.getMethod()) && result instanceof Collection) {
            result = postFilter((Collection<?>) result, mi.getMethod());
        }

        return result;
    }

    private Object[] preFilter(Object[] arguments, Method method) {
// PreFilter 어노테이션 추출 및 필터링 로직
        PreFilter annotation = method.getAnnotation(PreFilter.class);
        String filterExpression = annotation.value();

// 필터링할 인자 찾기 (컬렉션이나 배열)
        for (int i = 0; i < arguments.length; i++) {
            if (arguments[i] instanceof Collection) {
                Collection<?> collection = (Collection<?>) arguments[i];
                Collection<?> filtered = evaluateFilterExpression(collection, filterExpression);
                arguments[i] = filtered;
            }
        }

        return arguments;
    }

    private Collection<?> postFilter(Collection<?> result, Method method) {
// PostFilter 어노테이션 추출 및 필터링 로직
        PostFilter annotation = method.getAnnotation(PostFilter.class);
        String filterExpression = annotation.value();

        return evaluateFilterExpression(result, filterExpression);
    }

    private Collection<?> evaluateFilterExpression(Collection<?> collection, String expression) {
// SpEL 표현식 평가 로직// 각 항목에 대해 표현식을 평가하고 true를 반환하는 항목만 유지// ...
    }
}

```