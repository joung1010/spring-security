## 정적 자원 보호
스프링 시큐리티에서 RequestMatcher 인스턴스를 등록하여 무시해야할 요청을 지정할 수 있다.  
  
주로 정적자원(이미지, CSS, JavaScript)에 대한 요청이나 특정 엔드포인트가 보안 필터를 거치지지 않도록 설정할 때 사용된다.  
  
### 사용 방법
```java
@Bean
public WebSecurityCustomizer webSecurityCustomizer(){
    return (webSecurity) -> {
        webSecurity.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    };
    
}


```
  
**StaticResourceLocation**  
```java 
CSS("/css/**"),
    
JAVA_SCRIPT("/js/**"),
    
IMAGES("/images/**"),
    
WEB_JARS("/webjars/**"),
    
FAVICON("/favicon.*", "/*/icon-*");

```
  
### ignoring 보다 permitAll 권장
```java
   http
        .authorizeHttpRequests(authorize -> authorize
        .requestMatchers("/css/**","/js/**","/images/**","/webjars/**","/favicon.*", "/*/icon-*").permitAll()
        .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
        .anyRequest().authenticated());
```
이전에는 **모든 요청마다 세션을 확인해야 해서 성능 저하**가 있었지만, 시큐리티 6부터 권한 부여 규칙에서 필요한 경우를 제외하고느 세션을 확인하지 않는다.  
  
성능 문제가 해결되었기 때문에 모든 요청에 대해서 permitAll 을 사용할 것을 권장하며 정적 자원에 대한 요청일지라도 안전한 헤더를 작성할 수 있어서 더 안전한다.

>  보안 헤더 적용  
> Spring Security가 자동으로 추가하는 중요한 보안 헤더들:  
> - **X-Content-Type-Options**: MIME 스니핑 방지
> - **X-Frame-Options**: 클릭재킹 공격 방지
> - **X-XSS-Protection**: 크로스 사이트 스크립팅 공격 방지
> - **Content-Security-Policy**: 컨텐츠 보안 정책 설정
> - **Cache-Control**: 브라우저 캐싱 제어
> - **Strict-Transport-Security (HSTS)**: HTTPS 강제 적용  

## 왜 permitAll이 더 권장되는가?

1. **보안성 향상**:
    - 정적 자원에도 보안 헤더가 적용되어 전체적인 보안 수준 상승
    - XSS, 클릭재킹 등 다양한 웹 공격으로부터 보호 가능
2. **성능 문제 해결**:
    - Spring Security 6에서는 효율적인 필터 처리로 성능 오버헤드 해결
    - 세션 확인 최적화로 불필요한 세션 조회 제거
3. **일관성 있는 보안 정책**:
    - 모든 응답에 일관된 보안 정책을 적용할 수 있음
    - 애플리케이션 전체의 보안 구성을 단순화



